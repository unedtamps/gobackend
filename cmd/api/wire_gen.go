// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/goforj/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"github.com/unedtamps/gobackend/internal/bootstrap/database"
	"github.com/unedtamps/gobackend/internal/config"
	"github.com/unedtamps/gobackend/services"
	"log/slog"
	"os/signal"
	"syscall"
)

import (
	_ "github.com/golang-migrate/migrate/v4/source/file"
)

// Injectors from wire.go:

func InitializeApp(ctx context.Context, path string) (*App, error) {
	configConfig, err := config.NewAppConfiguration(path)
	if err != nil {
		return nil, err
	}
	db, err := database.NewDBInstance(ctx, configConfig)
	if err != nil {
		return nil, err
	}
	logger := config.NewLogger(configConfig)
	engine := services.Setup(logger)
	serverInterface := services.NewServer(db, configConfig, engine)
	app := &App{
		Server: serverInterface,
		Log:    logger,
		DB:     db,
	}
	return app, nil
}

// wire.go:

type App struct {
	Server services.ServerInterface
	Log    *slog.Logger
	DB     *database.DB
}

func main() {
	ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer stop()

	app, err := InitializeApp(ctx, ".")
	if err != nil {
		slog.Default().Error("Error initializing server", "err", err)
		return
	}

	go func() {
		if err := app.Server.Run(app.Log); err != nil {
			app.Log.Info("Server Error", "err", err)
			stop()
		}
	}()
	<-ctx.Done()
	app.Log.Info("Server is shutting down")
	app.DB.Close()
	app.Log.Info("Database connections closed")
	app.Log.Info("Server is gracefully shutdown")
}
